/* DocIntel
 * Copyright (C) 2018-2023 Belgian Defense, Antoine Cailliau, Kevin Menten
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

using AutoMapper;
using DocIntel.Core.Authentication;
using DocIntel.Core.Exceptions;
using DocIntel.Core.Logging;
using DocIntel.Core.Models;
using DocIntel.Core.Repositories;
using DocIntel.Core.Repositories.Query;
using DocIntel.Core.Utils;
using DocIntel.Core.Utils.Observables;
using DocIntel.Core.Utils.Search.Documents;
using DocIntel.WebApp.Areas.API.Models;
using DocIntel.WebApp.Helpers;

using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.ModelBinding;
using Microsoft.Extensions.Logging;
using Swashbuckle.AspNetCore.Annotations;

namespace DocIntel.WebApp.Areas.API.Controllers;

/// <summary>
/// A document, in the context of DocIntel, is a piece of electronic matter that provides information or evidence
/// or that serves as an official record. A document is a coherent set of files, like a PDF report and a CSV file
/// with the detailed, machine-processable, observables related to the PDF report.
///
/// ## Document Attributes
///
/// * *DocumentId*: The identifier
/// * *Title*: The title
/// * *Summary*: A short summary, in HTML, of the document. HTML is sanitized at input and output. 
/// * *ExternalReference*: The reference used by the source
/// * *SourceUrl*: The URL from which the document was retrieved
/// * *DocumentDate*: The publication date
/// * *RegistrationDate*: The registration date
/// * *ModificationDate*: The last modification date
/// * *Reference*: The reference, generated by DocIntel
/// * *URL*: The slug generated by DocIntel for pretty URLs
/// * *Note*: Notes 
/// * *SourceId*: The identifier of the source 
/// * *ClassificationId*: The identifier of the classification
/// * *Status*: The status of the document (0=Submitted, 1=Analyzed, 2=Registered)
/// 
/// ## Document Relationships
/// 
/// * *Tags*: The tags
/// * *Source*: The source
/// * *Classification*: The classification
/// * *RegisteredBy*: The user who registered the document
/// * *LastModifiedBy*: The user who last modified the document
/// </summary>
[Area("API")]
[Route("API/Document")]
[ApiController]
public class DocumentController : DocIntelAPIControllerBase
{
    private readonly IHttpContextAccessor _accessor;
    private readonly ICommentRepository _commentRepository;
    private readonly IClassificationRepository _classificationRepository;
    private readonly IDocumentRepository _documentRepository;
    private readonly ITagFacetRepository _facetRepository;
    private readonly ILogger<DocumentController> _logger;
    private readonly IMapper _mapper;
    private readonly ISynapseRepository _synapseRepository;
    private readonly ITagRepository _tagRepository;

    public DocumentController(UserManager<AppUser> userManager,
        DocIntelContext context,
        IDocumentRepository documentRepository,
        ILogger<DocumentController> logger,
        IMapper mapper,
        IHttpContextAccessor accessor,
        ITagRepository tagRepository,
        ITagFacetRepository facetRepository,
        ISynapseRepository synapseRepository,
        ICommentRepository commentRepository, IClassificationRepository classificationRepository)
        : base(userManager, context)
    {
        _documentRepository = documentRepository;
        _logger = logger;
        _mapper = mapper;
        _accessor = accessor;
        _tagRepository = tagRepository;
        _facetRepository = facetRepository;
        _commentRepository = commentRepository;
        _classificationRepository = classificationRepository;
        _synapseRepository = synapseRepository;
    }

    /// <summary>
    /// Get pending documents
    /// </summary>
    /// <remarks>
    /// Get the documents pending registration.
    ///
    /// For example, with cURL
    ///
    ///     curl --request GET \
    ///       --url http://localhost:5001/API/Document/Pending \
    ///       --header 'Authorization: Bearer $TOKEN'
    /// 
    /// </remarks>
    /// <param name="page">The page, starting from 1 (default: 1)</param>
    /// <param name="pageSize">The page size (default: 20)</param>
    /// <returns>The documents pending registration</returns>
    /// <response code="200">Returns the comments about the document</response>
    [HttpGet("Pending")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(IEnumerable<ApiDocumentDetails>))]
    [Produces("application/json")]
    [SwaggerOperation(
        OperationId = "GetPending"
    )]
    public async Task<IActionResult> Pending(int page = 1, int pageSize = 20)
    {
        var currentUser = await GetCurrentUser();
        var pendingDocuments = _documentRepository.GetAllAsync(AmbientContext, new DocumentQuery
            {
                Statuses = new[] {DocumentStatus.Submitted, DocumentStatus.Analyzed}.ToHashSet(),
                Page = page,
                Limit = pageSize,
                OrderBy = SortCriteria.RegistrationDate
            },
            new[] {nameof(Document.RegisteredBy), nameof(Document.LastModifiedBy)}).ToEnumerable();

        _logger.Log(LogLevel.Information,
            EventIDs.APIPendingDocumentSuccessful,
            new LogEvent($"User '{currentUser.UserName}' successfully listed pending documents.")
                .AddUser(currentUser)
                .AddHttpContext(_accessor.HttpContext),
            null,
            LogEvent.Formatter);

        return Ok(new
        {
            page,
            documents = _mapper.Map<IEnumerable<ApiDocumentDetails>>(pendingDocuments)
        });
    }

    /// <summary>
    /// Create a document
    /// </summary>
    /// <remarks>
    /// Creates a new document. The document has no files and is not registered. 
    ///
    /// For example, with cURL
    ///
    ///     curl --request POST \
    ///       --url http://localhost:5001/API/Document/ \
    ///       --header 'Authorization: Bearer $TOKEN' \
    ///       --header 'Content-Type: application/json' \
    ///       --data '{
    ///     	"title": "My document",
    ///     	"shortDescription": "My description",
    ///     	"sourceUrl": "https://docintel.org"
    ///     }'
    /// 
    /// </remarks>
    /// <param name="submittedDocument">The document</param>
    /// <returns>The created document, as recorded</returns>
    /// <response code="200">Returns the newly created document</response>
    /// <response code="401">Action is not authorized</response>
    /// <response code="400">Submitted value is invalid</response>
    [HttpPost("")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ApiDocumentDetails))]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [SwaggerOperation(
        OperationId = "Create"
    )]
    public async Task<IActionResult> Create([FromBody] ApiDocument submittedDocument)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            Tag[] filteredTags = null;
            var document = _mapper.Map<Document>(submittedDocument);
            document.Status = DocumentStatus.Submitted;
            if (submittedDocument.ClassificationId == null)
                document.ClassificationId = _classificationRepository.GetDefault(AmbientContext).ClassificationId;
            if (submittedDocument.Tags != null)
                filteredTags = (await GetTags(submittedDocument.Tags.ToArray(), currentUser)).ToArray();
            
            document = await _documentRepository.AddAsync(AmbientContext, document, filteredTags);
            await AmbientContext.DatabaseContext.SaveChangesAsync();
            
            _logger.Log(LogLevel.Information,
                EventIDs.UploadDocumentSuccessful,
                new LogEvent($"User '{currentUser.UserName}' successfully created a new document.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddDocument(document),
                null,
                LogEvent.Formatter);

            return Ok(_mapper.Map<ApiDocumentDetails>(document));
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.UploadDocumentFailed,
                new LogEvent($"User '{currentUser.UserName}' attempted to create a new document without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext),
                null,
                LogEvent.Formatter);
            
            return Unauthorized();
        }
        catch (InvalidArgumentException e)
        {
            ModelState.Clear();
            foreach (var kv in e.Errors)
            foreach (var errorMessage in kv.Value)
                ModelState.AddModelError(kv.Key, errorMessage);

            _logger.Log(LogLevel.Warning,
                EventIDs.UploadDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to create a new document' with invalid fields.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext),
                null,
                LogEvent.Formatter);

            return BadRequest(ModelState);
        }
    }

    /// <summary>
    /// Register a document
    /// </summary>
    /// <remarks>
    /// Register the document and merge the referenced observables into the main layer.
    ///
    /// For example, with cURL
    ///
    ///     curl --request POST \
    ///       --url http://localhost:5001/API/Document/d81f4853-5b79-4e4c-a60a-4360cf896ae0/Register \
    ///       --header 'Authorization: Bearer $TOKEN'
    /// 
    /// </remarks>
    /// <param name="documentId" example="d81f4853-5b79-4e4c-a60a-4360cf896ae0">The document identifier</param>
    /// <returns>The newly registered document</returns>
    /// <response code="200">Returns the registered document</response>
    /// <response code="404">The document does not exists.</response>
    /// <response code="401">Action is not authorized</response>
    [HttpPost("{documentId}/Register")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ApiDocumentDetails))]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [Produces("application/json")]
    public async Task<IActionResult> Register([FromRoute] Guid documentId)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            var document = await _documentRepository.GetAsync(AmbientContext,
                documentId);
            
            document.Status = DocumentStatus.Registered;

            if (ModelState.IsValid)
            {
                var updatedDoc = await _documentRepository.UpdateAsync(AmbientContext, document);
                await _synapseRepository.Merge(document);
                await _context.SaveChangesAsync();

                _logger.Log(LogLevel.Information,
                    EventIDs.APIRegisterDocumentSuccessful,
                    new LogEvent(
                            $"User '{currentUser.UserName}' successfully registered document '{documentId}'.")
                        .AddUser(currentUser)
                        .AddHttpContext(_accessor.HttpContext)
                        .AddProperty("document.id", documentId),
                    null,
                    LogEvent.Formatter);

                return Ok(_mapper.Map<ApiDocumentDetails>(updatedDoc));
            }

            throw new InvalidArgumentException(ModelState);
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIRegisterDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to register a document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIRegisterDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to register a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
        catch (FileAlreadyKnownException e)
        {
            _logger.Log(LogLevel.Information,
                EventIDs.APIRegisterDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to register a document that was already known.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.reference", e.ExistingReference),
                null,
                LogEvent.Formatter);
            return BadRequest();
        }
        catch (TitleAlreadyExistsException e)
        {
            _logger.Log(LogLevel.Information,
                EventIDs.APIRegisterDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to register a document with a title already known.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.reference", e.ExistingReference),
                null,
                LogEvent.Formatter);
            return BadRequest();
        }
        catch (InvalidArgumentException e)
        {
            ModelState.Clear();
            foreach (var kv in e.Errors)
            foreach (var errorMessage in kv.Value)
                ModelState.AddModelError(kv.Key, errorMessage);

            _logger.Log(LogLevel.Warning,
                EventIDs.APIRegisterDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to register a document '{documentId}' with invalid fields.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return BadRequest(ModelState);
        }
    }

    /// <summary>
    /// Subscribe to a document
    /// </summary>
    /// <remarks>
    /// Subscribe to the document. The body indicates whether the user should receive a notification
    /// when the document changes.
    ///
    /// For example, with cURL
    ///
    ///     curl --request PUT \
    ///       --url http://localhost:5001/API/Document/a203c3dd-72e2-488f-a999-a4a8a7acd0a8/Subscribe \
    ///       --header 'Authorization: Bearer $TOKEN' \
    ///       --header 'Content-Type: application/json' \
    ///       --data false
    /// 
    /// </remarks>
    /// <param name="documentId" example="a203c3dd-72e2-488f-a999-a4a8a7acd0a8">The document identifier</param>
    /// <param name="notification" example="false">Whether the user needs to be notified</param>
    /// <response code="200">User is subscribed to the document</response>
    /// <response code="404">The document does not exists.</response>
    /// <response code="401">Action is not authorized</response>
    [HttpPut("{documentId}/Subscribe")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(void))]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [Produces("application/json")]
    public async Task<IActionResult> Subscribe([FromRoute] Guid documentId, [FromBody] bool notification = false)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            var document = await _documentRepository.GetAsync(AmbientContext,
                new DocumentQuery
                {
                    DocumentId = documentId
                });

            await _documentRepository.SubscribeAsync(AmbientContext, document.DocumentId, notification);
            await _context.SaveChangesAsync();

            _logger.Log(LogLevel.Information,
                EventIDs.APISubscribeDocumentSuccessful,
                new LogEvent($"User '{currentUser.UserName}' successfully subscribed to document '{documentId}' (notifications: {notification}).")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddDocument(document),
                null,
                LogEvent.Formatter);

            return Ok();
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APISubscribeDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to subscribe to document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APISubscribeDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to subscribe to a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
    }

    /// <summary>
    /// Unsubscribe to a document
    /// </summary>
    /// <remarks>
    /// Unsubscribe to the document.
    ///
    /// For example, with cURL
    ///
    ///     curl --request PUT \
    ///       --url http://localhost:5001/API/Document/a203c3dd-72e2-488f-a999-a4a8a7acd0a8/Unsubscribe \
    ///       --header 'Authorization: Bearer $TOKEN' \
    ///       --header 'Content-Type: application/json'
    /// 
    /// </remarks>
    /// <param name="documentId" example="a203c3dd-72e2-488f-a999-a4a8a7acd0a8">The document identifier</param>
    /// <response code="200">User is not subscribed to the document</response>
    /// <response code="404">The document does not exists.</response>
    /// <response code="401">Action is not authorized</response>
    [HttpPut("{documentId}/Unsubscribe")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [Produces("application/json")]
    public async Task<IActionResult> Unsubscribe([FromRoute] Guid documentId)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            var document = await _documentRepository.GetAsync(AmbientContext, new DocumentQuery {DocumentId = documentId});

            await _documentRepository.UnsubscribeAsync(AmbientContext, document.DocumentId);
            await _context.SaveChangesAsync();

            _logger.Log(LogLevel.Information,
                EventIDs.APIUnsubscribeDocumentSuccessful,
                new LogEvent($"User '{currentUser.UserName}' successfully unsubscribed from document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddDocument(document),
                null,
                LogEvent.Formatter);

            return Ok();
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIUnsubscribeDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to unsubscribe from document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIUnsubscribeDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to unsubscribe from a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
    }
    
    /// <summary>
    /// Get subscription status
    /// </summary>
    /// <remarks>
    /// Gets whether the user is subscribed to the document.
    ///
    /// For example, with cURL
    ///
    ///     curl --request GET \
    ///       --url http://localhost:5001/API/Document/4a9ef072-0cc5-41f8-b42a-a018ef4fb4b8/Subscription \
    ///       --header 'Authorization: Bearer $TOKEN'
    /// 
    /// </remarks>
    /// <param name="documentId" example="4a9ef072-0cc5-41f8-b42a-a018ef4fb4b8">The document identifier</param>
    /// <returns>The subscription to the document</returns>
    /// <response code="200">Return the user subscription to the document</response>
    /// <response code="404">The document does not exists.</response>
    /// <response code="401">Action is not authorized</response>
    [HttpGet("{documentId}/Subscription")]
    [ProducesResponseType(StatusCodes.Status200OK, Type=typeof(ApiSubscriptionStatus))]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [Produces("application/json")]
    public async Task<IActionResult> Subscription([FromRoute] Guid documentId)
    {
        var currentUser = await GetCurrentUser();

        try
        {
            var result = await _documentRepository.IsSubscribedAsync(AmbientContext, documentId);

            _logger.Log(LogLevel.Information,
                EventIDs.APISubscribeSuccessful,
                new LogEvent($"User '{currentUser.UserName}' queried subscription to document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Ok(_mapper.Map<ApiSubscriptionStatus>(result));
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APISubscribeFacetFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to query subscription to document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APISubscribeFacetFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to query subscription to a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
    }

    /// <summary>
    /// Get a document
    /// </summary>
    /// <remarks>
    /// Gets the details of a document
    ///
    /// For example, with cURL
    ///
    ///     curl --request GET \
    ///       --url http://localhost:5001/API/Document/3601df56-ae41-4d5b-a440-d77094322240 \
    ///       --header 'Authorization: Bearer $TOKEN'
    /// 
    /// </remarks>
    /// <param name="documentId" example="3601df56-ae41-4d5b-a440-d77094322240">The document identifier</param>
    /// <returns>The document</returns>
    /// <response code="200">Returns the newly created document</response>
    /// <response code="401">Action is not authorized</response>
    /// <response code="404">The document does not exist</response>
    [HttpGet("{documentId}")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ApiDocumentDetails))]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [SwaggerOperation(
        OperationId = "Get"
    )]
    public async Task<IActionResult> Details(Guid documentId)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            var document = await _documentRepository.GetAsync(AmbientContext, documentId,
                new[]
                {
                    nameof(Document.Files),
                    nameof(Document.DocumentTags),
                    nameof(Document.DocumentTags) + "." + nameof(DocumentTag.Tag),
                    nameof(Document.DocumentTags) + "." + nameof(DocumentTag.Tag) + "." + nameof(Tag.Facet),
                    nameof(Document.Source),
                    nameof(Document.Comments),
                    nameof(Document.ReleasableTo),
                    nameof(Document.EyesOnly)
                });

            var value = new
            {
                document = _mapper.Map<ApiDocumentDetails>(document),
                subcribed = await _documentRepository.IsSubscribedAsync(AmbientContext, document.DocumentId),
                comments = _mapper.Map<IEnumerable<ApiCommentDetails>>(
                    await _commentRepository
                        .GetAllAsync(AmbientContext, new CommentQuery {DocumentId = document.DocumentId})
                        .ToListAsync()
                )
            };

            _logger.Log(LogLevel.Warning,
                EventIDs.APIDetailsDocumentSuccessful,
                new LogEvent($"User '{currentUser.UserName}' successfully viewed document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return base.Ok(
                value
            );
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIDetailsDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to view document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIDetailsDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to view a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
    }

    /// <summary>
    /// Updates a document
    /// </summary>
    /// <remarks>
    /// Updates a document
    ///
    /// For example, with cURL
    ///
    ///     curl --request PATCH \
    ///       --url http://localhost:5001/API/Document/ \
    ///       --header 'Authorization: Bearer $TOKEN' \
    ///       --header 'Content-Type: application/json' \
    ///       --data '{
    ///     	"title": "Looking for the Sliver lining: Hunting for emerging command-and-control frameworks",
    ///     	"tags": [
    ///     		"targetGeography:united kingdom",
    ///     		"technique.commandAndControl:T1071 - Application Layer Protocol",
    ///     		"technique.initialAccess:T1078 - Valid Accounts",
    ///     		"technique.execution:T1059.005 - Visual Basic",
    ///     		"technique.initialAccess:T1195 - Supply Chain Compromise",
    ///     		"technique.collection:T1114 - Email Collection",
    ///     		"technique.commandAndControl:T1071.004 - DNS",
    ///     		"targetGeography:Europe",
    ///     		"vulnerability:CVE-2019-19781",
    ///     		"vulnerability:CVE-2018-13379",
    ///     		"technique.credentialAccess:T1552.004 - Private Keys",
    ///     		"technique.persistence:T1078 - Valid Accounts",
    ///     		"technique.collection:T1114.002 - Remote Email Collection",
    ///     		"vulnerability:CVE-2021-26858",
    ///     		"technique.initialAccess:T1195.002 - Compromise Software Supply Chain",
    ///     		"technique.reconnaissance:T1595.002 - Vulnerability Scanning",
    ///     		"technique.persistence:T1505 - Server Software Component",
    ///     		"technique.initialAccess:T1190 - Exploit Public-Facing Application",
    ///     		"vulnerability:CVE-2019-11510",
    ///     		"technique.commandAndControl:T1573.002 - Asymmetric Cryptography",
    ///     		"targetGeography:united states",
    ///     		"vulnerability:CVE-2021-26855",
    ///     		"technique.execution:T1059 - Command and Scripting Interpreter",
    ///     		"vulnerability:CVE-2021-27065",
    ///     		"technique.persistence:T1505.003 - Web Shell",
    ///     		"technique.credentialAccess:T1552 - Unsecured Credentials",
    ///     		"technique.initialAccess:T1199 - Trusted Relationship",
    ///     		"technique.reconnaissance:T1595 - Active Scanning",
    ///     		"vulnerability:CVE-2021-26857",
    ///     		"technique.defenseEvasion:T1078 - Valid Accounts",
    ///     		"technique.commandAndControl:T1573 - Encrypted Channel",
    ///     		"technique.privilegeEscalation:T1078 - Valid Accounts",
    ///     		"tool:Cobalt Strike",
    ///     		"targetGeography:russia",
    ///     		"technique.commandAndControl:T1071.001 - Web Protocols",
    ///     		"group.microsoft:DEV-0237",
    ///     		"group.microsoft:HAFNIUM",
    ///     		"vulnerability:CVE-2021-21972",
    ///     		"vulnerability:CVE-2019-1653",
    ///     		"group.mandiant:UNC2452",
    ///     		"vulnerability:CVE-2020-14882",
    ///     		"vulnerability:CVE-2020-5902",
    ///     		"vulnerability:CVE-2019-2725",
    ///     		"group.mandiant:APT29",
    ///     		"vulnerability:CVE-2020-4006",
    ///     		"vulnerability:CVE-2019-9670",
    ///     		"vulnerability:CVE-2019-7609"
    ///     	]
    ///     }'
    /// 
    /// </remarks>
    /// <param name="documentId" example="befa4d31-76a9-48ad-9f64-bf1cb1788e3e">The document identifier</param>
    /// <param name="submittedDocument">The updated document</param>
    /// <returns>The updated document</returns>
    /// <response code="200">Returns the newly updated document</response>
    /// <response code="401">Action is not authorized</response>
    /// <response code="404">The document does not exist</response>
    [HttpPatch("{documentId}")]
    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ApiDocumentDetails))]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    [Produces("application/json")]
    public async Task<IActionResult> Update([FromRoute] Guid documentId, [FromBody] ApiDocument submittedDocument)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            var document = await _documentRepository.GetAsync(AmbientContext,
                documentId);

            ISet<Tag> filteredTags = null;
            if (submittedDocument.Tags != null)
                filteredTags = await GetTags(submittedDocument.Tags.ToArray(), currentUser);
            document = _mapper.Map(submittedDocument, document);

            if (ModelState.IsValid)
            {
                var updatedDoc = await _documentRepository.UpdateAsync(AmbientContext, document, filteredTags);

                await _context.SaveChangesAsync();

                _logger.Log(LogLevel.Information,
                    EventIDs.APIUpdateDocumentSuccessful,
                    new LogEvent(
                            $"User '{currentUser.UserName}' successfully updated document '{documentId}'.")
                        .AddUser(currentUser)
                        .AddHttpContext(_accessor.HttpContext)
                        .AddProperty("document.id", documentId),
                    null,
                    LogEvent.Formatter);

                return Ok(_mapper.Map<ApiDocumentDetails>(updatedDoc));
            }

            throw new InvalidArgumentException(ModelState);
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIUpdateDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to update a document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIUpdateDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to update a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
        catch (FileAlreadyKnownException e)
        {
            _logger.Log(LogLevel.Information,
                EventIDs.APIUpdateDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to upload a document that was already known.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.reference", e.ExistingReference),
                null,
                LogEvent.Formatter);
            return BadRequest();
        }
        catch (TitleAlreadyExistsException e)
        {
            _logger.Log(LogLevel.Information,
                EventIDs.APIUpdateDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to upload a document with a title already known.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.reference", e.ExistingReference),
                null,
                LogEvent.Formatter);
            return BadRequest();
        }
        catch (InvalidArgumentException e)
        {
            ModelState.Clear();
            foreach (var kv in e.Errors)
            foreach (var errorMessage in kv.Value)
                ModelState.AddModelError(kv.Key, errorMessage);

            _logger.Log(LogLevel.Warning,
                EventIDs.APIUpdateDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to update a document '{documentId}' with invalid fields.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return BadRequest(ModelState);
        }
    }

    /// <summary>
    /// Deletes a document
    /// </summary>
    /// <remarks>
    /// Deletes the specified document, the related files, and removes the references to the observable.
    ///
    /// For example, with cURL
    ///
    ///     curl --request DELETE \
    ///       --url http://localhost:5001/API/Document/6e7635a0-27bb-495d-a218-15b54cb938fd \
    ///       --header 'Authorization: Bearer $TOKEN'
    ///
    /// </remarks>
    /// <param name="documentId" example="6e7635a0-27bb-495d-a218-15b54cb938fd">The document identifier</param>
    /// <response code="200">The document is deleted</response>
    /// <response code="401">Action is not authorized</response>
    /// <response code="404">The document does not exist</response>
    [HttpDelete("{documentId}")]
    [ProducesResponseType(StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [Produces("application/json")]
    public async Task<IActionResult> Delete([FromRoute] Guid documentId)
    {
        var currentUser = await GetCurrentUser();
        try
        {
            var trackingEntity = await _documentRepository.RemoveAsync(AmbientContext, documentId);
            await _synapseRepository.Remove(documentId);
            await _context.SaveChangesAsync();

            _logger.Log(LogLevel.Information,
                EventIDs.APIDeleteDocumentSuccessful,
                new LogEvent($"User '{currentUser.UserName}' successfully deleted document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Ok();
        }
        catch (UnauthorizedOperationException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIDeleteDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to update a document '{documentId}' without legitimate rights.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return Unauthorized();
        }
        catch (NotFoundEntityException)
        {
            _logger.Log(LogLevel.Warning,
                EventIDs.APIDeleteDocumentFailed,
                new LogEvent(
                        $"User '{currentUser.UserName}' attempted to update a non-existing document '{documentId}'.")
                    .AddUser(currentUser)
                    .AddHttpContext(_accessor.HttpContext)
                    .AddProperty("document.id", documentId),
                null,
                LogEvent.Formatter);

            return NotFound();
        }
    }

    #region Helpers

    // REFACTOR to avoid code duplication with non-API controller.

    private async Task<ISet<Tag>> GetTags(string[] tags, AppUser currentUser)
    {
        var filteredTags = new HashSet<Tag>();

        // A cache is needed in order to avoid creating multiple time a new
        // facet with the same prefix when adding multiple tags. E.g. assume
        // that facet "test" is not known, and tags contains { "test:a", 
        // "test:b" }. Without the cache, the code would create a facet 
        // with prefix "test" twice, as it would not get it from database
        // (changes are not yet commited). EF Core caching should handle the
        // case and it could be later investigated.
        var facetCache = new Dictionary<string, TagFacet>();
        foreach (var label in tags.Distinct())
            try
            {
                filteredTags.Add(await CreateOrAddTag(currentUser, facetCache, label));
            }
            catch (UnauthorizedOperationException)
            {
            }

        // check that there is a tag for all mandatory facets
        var mandatoryFacets = _facetRepository.GetAllAsync(AmbientContext, new FacetQuery
        {
            Mandatory = true
        }).ToEnumerable();
        var mandatoryIds = mandatoryFacets.Select(_ => _.FacetId).ToHashSet();
        var facetsPresents = filteredTags.Select(_ => _.FacetId).ToHashSet();

        if (mandatoryIds.Except(facetsPresents).Any())
        {
            var values = mandatoryFacets.Where(_ => !facetsPresents.Contains(_.FacetId)).Select(_ => _.Title);
            var str = (values.Count() > 1 ? "Facets " : "The facet ") + string.Join(", ", values) +
                      (values.Count() > 1 ? " are " : " is ") + " mandatory.";
            ModelState.AddModelError("Tags", str);
        }

        return filteredTags;
    }

    private async Task<Tag> CreateOrAddTag(AppUser user, Dictionary<string, TagFacet> facetCache, string label)
    {
        var facetName = "";
        var tagName = label;
        if (tagName.IndexOf(':') > 0)
        {
            facetName = label.Split(':', 2)[0];
            tagName = label.Split(':', 2)[1];
        }

        TagFacet facet;
        if (facetCache.ContainsKey(facetName))
            facet = facetCache[facetName];
        else
            try
            {
                facet = await _facetRepository.GetAsync(AmbientContext, facetName);
                facetCache[facet.Prefix] = facet;
            }
            catch (NotFoundEntityException)
            {
                facet = await _facetRepository.AddAsync(AmbientContext,
                    new TagFacet {Prefix = facetName, Title = facetName});
                facetCache[facet.Prefix] = facet;
            }

        Tag tag;
        try
        {
            tag = await _tagRepository.GetAsync(AmbientContext, facet.FacetId, tagName);
        }
        catch (NotFoundEntityException)
        {
            tag = await _tagRepository.CreateAsync(AmbientContext, new Tag {FacetId = facet.FacetId, Label = tagName});
        }

        return tag;
    }

    #endregion
}